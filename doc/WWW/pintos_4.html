<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html40/loose.dtd">
<HTML>
<!-- Created on October, 26 2020 by texi2html 1.66 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<HEAD>
<TITLE>Pintos Projects: Project 3--Virtual Memory</TITLE>

<META NAME="description" CONTENT="Pintos Projects: Project 3--Virtual Memory">
<META NAME="keywords" CONTENT="Pintos Projects: Project 3--Virtual Memory">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.66">
<LINK REL="stylesheet" HREF="pintos.css">
</HEAD>

<BODY >

<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_3.html#SEC32"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_5.html#SEC75"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<H1> 4. Project 3: Virtual Memory </H1>
<!--docid::SEC53::-->
<P>

By now you should have some familiarity with the inner workings of
Pintos.  Your
OS can properly handle multiple threads of execution with proper
synchronization, and can load multiple user programs at once.  However,
the number and size of programs that can run is limited by the machine's
main memory size.  In this assignment, you will remove that limitation.
</P>
<P>

You will build this assignment on top of the last one.  Test programs
from project 2 should also work with project 3.  You should take care to
fix any bugs in your project 2 submission before you start work on
project 3, because those bugs will most likely cause the same problems
in project 3.
</P>
<P>

You will continue to handle Pintos disks and file systems the same way
you did in the previous assignment (see section <A HREF="pintos_3.html#SEC35">3.1.2 Using the File System</A>).
</P>
<P>

<A NAME="Project 3 Background"></A>
<HR SIZE="6">
<A NAME="SEC54"></A>
<H2> 4.1 Background </H2>
<!--docid::SEC54::-->
<P>

<A NAME="Project 3 Source Files"></A>
<HR SIZE="6">
<A NAME="SEC55"></A>
<H3> 4.1.1 Source Files </H3>
<!--docid::SEC55::-->
<P>

You will work in the <Q><TT>vm</TT></Q> directory for this project.  The
<Q><TT>vm</TT></Q> directory contains only <Q><TT>Makefile</TT></Q>s.  The only
change from <Q><TT>userprog</TT></Q> is that this new <Q><TT>Makefile</TT></Q> turns on
the setting <Q><SAMP>-DVM</SAMP></Q>.  All code you write will be in new
files or in files introduced in earlier projects.
</P>
<P>

You will probably be encountering just a few files for the first time:
</P>
<P>

</P>
<DL COMPACT>
<DT><Q><TT>devices/block.h</TT></Q>
<DD><DT><Q><TT>devices/block.c</TT></Q>
<DD>Provides sector-based read and write access to block device.  You will
use this interface to access the swap partition as a block device.
</DL>
<P>

<A NAME="Memory Terminology"></A>
<HR SIZE="6">
<A NAME="SEC56"></A>
<H3> 4.1.2 Memory Terminology </H3>
<!--docid::SEC56::-->
<P>

Careful definitions are needed to keep discussion of virtual memory from
being confusing.  Thus, we begin by presenting some terminology for
memory and storage.  Some of these terms should be familiar from project
2 (see section <A HREF="pintos_3.html#SEC37">3.1.4 Virtual Memory Layout</A>), but much of it is new.
</P>
<P>

<A NAME="Pages"></A>
<HR SIZE="6">
<A NAME="SEC57"></A>
<H4> 4.1.2.1 Pages </H4>
<!--docid::SEC57::-->
<P>

A <EM>page</EM>, sometimes called a <EM>virtual page</EM>, is a continuous
region of virtual memory 4,096 bytes (the <EM>page size</EM>) in length.  A
page must be <EM>page-aligned</EM>, that is, start on a virtual address
evenly divisible by the page size.  Thus, a 32-bit virtual address can
be divided into a 20-bit <EM>page number</EM> and a 12-bit <EM>page
offset</EM> (or just <EM>offset</EM>), like this:
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>               31               12 11        0
              +-------------------+-----------+
              |    Page Number    |   Offset  |
              +-------------------+-----------+
                       Virtual Address
</pre></td></tr></table><P>

Each process has an independent set of <EM>user (virtual) pages</EM>, which
are those pages below virtual address <CODE>PHYS_BASE</CODE>, typically
<TT>0xc0000000</TT> (3 GB).  The set of <EM>kernel (virtual) pages</EM>, on the
other hand, is global, remaining the same regardless of what thread or
process is active.  The kernel may access both user and kernel pages,
but a user process may access only its own user pages.  See section <A HREF="pintos_3.html#SEC37">3.1.4 Virtual Memory Layout</A>, for more information.
</P>
<P>

Pintos provides several useful functions for working with virtual
addresses.  See section <A HREF="pintos_6.html#SEC114">A.6 Virtual Addresses</A>, for details.
</P>
<P>

<A NAME="Frames"></A>
<HR SIZE="6">
<A NAME="SEC58"></A>
<H4> 4.1.2.2 Frames </H4>
<!--docid::SEC58::-->
<P>

A <EM>frame</EM>, sometimes called a <EM>physical frame</EM> or a <EM>page
frame</EM>, is a continuous region of physical memory.  Like pages, frames
must be page-size and page-aligned.  Thus, a 32-bit physical address can
be divided into a 20-bit <EM>frame number</EM> and a 12-bit <EM>frame
offset</EM> (or just <EM>offset</EM>), like this:
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>               31               12 11        0
              +-------------------+-----------+
              |    Frame Number   |   Offset  |
              +-------------------+-----------+
                       Physical Address
</pre></td></tr></table><P>

The 80<VAR>x</VAR>86 doesn't provide any way to directly access memory at a
physical address.  Pintos works around this by mapping kernel virtual
memory directly to physical memory: the first page of kernel virtual
memory is mapped to the first frame of physical memory, the second page
to the second frame, and so on.  Thus, frames can be accessed through
kernel virtual memory.  
</P>
<P>

Pintos provides functions for translating between physical addresses and
kernel virtual addresses.  See section <A HREF="pintos_6.html#SEC114">A.6 Virtual Addresses</A>, for details.
</P>
<P>

<A NAME="Page Tables"></A>
<HR SIZE="6">
<A NAME="SEC59"></A>
<H4> 4.1.2.3 Page Tables </H4>
<!--docid::SEC59::-->
<P>

In Pintos, a <EM>page table</EM> is a data structure that the CPU uses to
translate a virtual address to a physical address, that is, from a page
to a frame.  The page table format is dictated by the 80<VAR>x</VAR>86
architecture.  Pintos provides page table management code in
<Q><TT>pagedir.c</TT></Q> (see section <A HREF="pintos_6.html#SEC115">A.7 Page Table</A>).
</P>
<P>

The diagram below illustrates the relationship between pages and frames.
The virtual address, on the left, consists of a page number and an
offset.  The page table translates the page number into a frame number,
which is combined with the unmodified offset to obtain the physical
address, on the right.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>                          +----------+
         .---------------&gt;|Page Table|---------.
        /                 +----------+          |
   31   |   12 11    0                    31    V   12 11    0
  +-----------+-------+                  +------------+-------+
  |  Page Nr  |  Ofs  |                  |  Frame Nr  |  Ofs  |
  +-----------+-------+                  +------------+-------+
   Virt Addr      |                       Phys Addr       ^
                   \_____________________________________/
</pre></td></tr></table><P>

<A NAME="Swap Slots"></A>
<HR SIZE="6">
<A NAME="SEC60"></A>
<H4> 4.1.2.4 Swap Slots </H4>
<!--docid::SEC60::-->
<P>

A <EM>swap slot</EM> is a continuous, page-size region of disk space in the
swap partition.  Although hardware limitations dictating the placement of
slots are looser than for pages and frames, swap slots should be
page-aligned because there is no downside in doing so.
</P>
<P>

<A NAME="Resource Management Overview"></A>
<HR SIZE="6">
<A NAME="SEC61"></A>
<H3> 4.1.3 Resource Management Overview </H3>
<!--docid::SEC61::-->
<P>

You will need to design the following data structures:
</P>
<P>

</P>
<DL COMPACT>
<DT>Supplemental page table
<DD><P>

Enables page fault handling by supplementing the hadrware page table.
See section <A HREF="pintos_4.html#SEC62">4.1.4 Managing the Supplemental Page Table</A>.
</P>
<P>

</P>
<DT>Frame table
<DD><P>

Allows efficient implementation of eviction policy.
See section <A HREF="pintos_4.html#SEC63">4.1.5 Managing the Frame Table</A>.
</P>
<P>

</P>
<DT>Swap table
<DD><P>

Tracks usage of swap slots.
See section <A HREF="pintos_4.html#SEC65">4.1.6 Managing the Swap Table</A>.
</P>
<P>

</P>
<DT>Table of file mappings
<DD><P>

Processes may map files into their virtual memory space.  You need a
table to track which files are mapped into which pages.
</DL>
<P>

You do not necessarily need to implement four completely distinct data
structures: it may be convenient to wholly or partially merge related
resources into a unified data structure.
</P>
<P>

For each data structure, you need to determine what information each
element should contain.  You also need to decide on the data structure's
scope, either local (per-process) or global (applying to the whole
system), and how many instances are required within its scope.
</P>
<P>

To simplify your design, you may store these data structures in
non-pageable memory.  That means that you can be sure that pointers
among them will remain valid.
</P>
<P>

Possible choices of data structures include arrays, lists, bitmaps, and
hash tables.  An array is often the simplest approach, but a sparsely
populated array wastes memory.  Lists are also simple, but traversing a
long list to find a particular position wastes time.  Both arrays and
lists can be resized, but lists more efficiently support insertion and
deletion in the middle.
</P>
<P>

Pintos includes a bitmap data structure in <Q><TT>lib/kernel/bitmap.c</TT></Q>
and <Q><TT>lib/kernel/bitmap.h</TT></Q>.  A bitmap is an array of bits, each of
which can be true or false.  Bitmaps are typically used to track usage
in a set of (identical) resources: if resource <VAR>n</VAR> is in use, then
bit <VAR>n</VAR> of the bitmap is true.  Pintos bitmaps are fixed in size,
although you could extend their implementation to support resizing.
</P>
<P>

Pintos also includes a hash table data structure (see section <A HREF="pintos_6.html#SEC123">A.8 Hash Table</A>).
Pintos hash tables efficiently support insertions and deletions over a
wide range of table sizes.
</P>
<P>

Although more complex data structures may yield performance or other
benefits, they may also needlessly complicate your implementation.
Thus, we do not recommend implementing any advanced data structure
(e.g. a balanced binary tree) as part of your design.
</P>
<P>

<A NAME="Managing the Supplemental Page Table"></A>
<HR SIZE="6">
<A NAME="SEC62"></A>
<H3> 4.1.4 Managing the Supplemental Page Table </H3>
<!--docid::SEC62::-->
<P>

The <EM>supplemental page table</EM> supplements the page table with
additional data about each page.  It is needed because of the
limitations imposed by the page table's format.  Such a data structure
is often called a &quot;page table&quot; also; we add the word &quot;supplemental&quot;
to reduce confusion.
</P>
<P>

The supplemental page table is used for at least two purposes.  Most
importantly, on a page fault, the kernel looks up the virtual page that
faulted in the supplemental page table to find out what data should be
there.  Second, the kernel consults the supplemental page table when a
process terminates, to decide what resources to free.
</P>
<P>

You may organize the supplemental page table as you wish.  There are at
least two basic approaches to its organization: in terms of segments or
in terms of pages.  Optionally, you may use the page table itself as an
index to track the members of the supplemental page table.  You will
have to modify the Pintos page table implementation in <Q><TT>pagedir.c</TT></Q>
to do so.  We recommend this approach for advanced students only.
See section <A HREF="pintos_6.html#SEC121">A.7.4.2 Page Table Entry Format</A>, for more information.
</P>
<P>

The most important user of the supplemental page table is the page fault
handler.  In project 2, a page fault always indicated a bug in the
kernel or a user program.  In project 3, this is no longer true.  Now, a
page fault might only indicate that the page must be brought in from a
file or swap.  You will have to implement a more sophisticated page
fault handler to handle these cases.  Your page fault handler, which you
should implement by modifying <CODE>page_fault()</CODE> in
<Q><TT>userprog/exception.c</TT></Q>, needs to do roughly the following:
</P>
<P>

<OL>
<LI>
Locate the page that faulted in the supplemental page table.  If the
memory reference is valid, use the supplemental page table entry to
locate the data that goes in the page, which might be in the file
system, or in a swap slot, or it might simply be an all-zero page.  If
you implement sharing, the page's data might even already be in a page
frame, but not in the page table.
<P>

If the supplemental page table indicates that the user process should
not expect any data at the address it was trying to access, or if the
page lies within kernel virtual memory, or if the access is an attempt
to write to a read-only page, then the access is invalid.  Any invalid
access terminates the process and thereby frees all of its resources.
</P>
<P>

</P>
<LI>
Obtain a frame to store the page.  See section <A HREF="pintos_4.html#SEC63">4.1.5 Managing the Frame Table</A>, for
details.
<P>

If you implement sharing, the data you need may already be in a frame,
in which case you must be able to locate that frame.
</P>
<P>

</P>
<LI>
Fetch the data into the frame, by reading it from the file system or
swap, zeroing it, etc.
<P>

If you implement sharing, the page you need may already be in a frame,
in which case no action is necessary in this step.
</P>
<P>

</P>
<LI>
Point the page table entry for the faulting virtual address to the
physical page.  You can use the functions in <Q><TT>userprog/pagedir.c</TT></Q>.
</OL>
<P>

<A NAME="Managing the Frame Table"></A>
<HR SIZE="6">
<A NAME="SEC63"></A>
<H3> 4.1.5 Managing the Frame Table </H3>
<!--docid::SEC63::-->
<P>

The <EM>frame table</EM> contains one entry for each frame that contains a
user page.  Each entry in the frame table contains a pointer to the
page, if any, that currently occupies it, and other data of your choice.
The frame table allows Pintos to efficiently implement an eviction
policy, by choosing a page to evict when no frames are free.
</P>
<P>

The frames used for user pages should be obtained from the &quot;user
pool,&quot; by calling <CODE>palloc_get_page(PAL_USER)</CODE>.  You must use
<CODE>PAL_USER</CODE> to avoid allocating from the &quot;kernel pool,&quot; which
could cause some test cases to fail unexpectedly (see  <A HREF="pintos_4.html#Why PAL_USER?">Why PAL_USER?</A>).  If you modify <Q><TT>palloc.c</TT></Q> as part of your frame table
implementation, be sure to retain the distinction between the two pools.
</P>
<P>

The most important operation on the frame table is obtaining an unused
frame.  This is easy when a frame is free.  When none is free, a frame
must be made free by evicting some page from its frame.
</P>
<P>

If no frame can be evicted without allocating a swap slot, but swap is
full, panic the kernel.  Real OSes apply a wide range of policies to
recover from or prevent such situations, but these policies are beyond
the scope of this project.
</P>
<P>

The process of eviction comprises roughly the following steps:
</P>
<P>

<OL>
<LI>
Choose a frame to evict, using your page replacement algorithm.  The
&quot;accessed&quot; and &quot;dirty&quot; bits in the page table, described below, will
come in handy.
<P>

</P>
<LI>
Remove references to the frame from any page table that refers to it.
<P>

Unless you have implemented sharing, only a single page should refer to
a frame at any given time.
</P>
<P>

</P>
<LI>
If necessary, write the page to the file system or to swap.
</OL>
<P>

The evicted frame may then be used to store a different page.
</P>
<P>

<A NAME="Accessed and Dirty Bits"></A>
<HR SIZE="6">
<A NAME="SEC64"></A>
<H4> 4.1.5.1 Accessed and Dirty Bits </H4>
<!--docid::SEC64::-->
<P>

80<VAR>x</VAR>86 hardware provides some assistance for implementing page
replacement algorithms, through a pair of bits in the page table entry
(PTE) for each page.  On any read or write to a page, the CPU sets the
<EM>accessed bit</EM> to 1 in the page's PTE, and on any write, the CPU
sets the <EM>dirty bit</EM> to 1.  The CPU never resets these bits to 0,
but the OS may do so.
</P>
<P>

You need to be aware of <EM>aliases</EM>, that is, two (or more) pages that
refer to the same frame.  When an aliased frame is accessed, the
accessed and dirty bits are updated in only one page table entry (the
one for the page used for access).  The accessed and dirty bits for the
other aliases are not updated.
</P>
<P>

In Pintos, every user virtual page is aliased to its kernel virtual
page.  You must manage these aliases somehow.  For example, your code
could check and update the accessed and dirty bits for both addresses.
Alternatively, the kernel could avoid the problem by only accessing user
data through the user virtual address.
</P>
<P>

Other aliases should only arise if you implement sharing for extra
credit (see  <A HREF="pintos_4.html#VM Extra Credit">VM Extra Credit</A>), or if there is a bug in your code.
</P>
<P>

See section <A HREF="pintos_6.html#SEC118">A.7.3 Accessed and Dirty Bits</A>, for details of the functions
to work with accessed and dirty bits.
</P>
<P>

<A NAME="Managing the Swap Table"></A>
<HR SIZE="6">
<A NAME="SEC65"></A>
<H3> 4.1.6 Managing the Swap Table </H3>
<!--docid::SEC65::-->
<P>

The swap table tracks in-use and free swap slots.  It should allow
picking an unused swap slot for evicting a page from its frame to the
swap partition.  It should allow freeing a swap slot when its page is read
back or the process whose page was swapped is terminated.
</P>
<P>

You may use the <CODE>BLOCK_SWAP</CODE> block device for swapping, obtaining
the <CODE>struct block</CODE> that represents it by calling <CODE>block_get_role()</CODE>.
From the
<Q><TT>vm/build</TT></Q> directory, use the command <CODE>pintos-mkdisk swap.dsk
--swap-size=<VAR>n</VAR></CODE> to create an disk named <Q><TT>swap.dsk</TT></Q> that
contains a <VAR>n</VAR>-MB swap partition.
Afterward, <Q><TT>swap.dsk</TT></Q> will automatically be attached as an extra disk
when you run <CODE>pintos</CODE>.  Alternatively, you can tell
<CODE>pintos</CODE> to use a temporary <VAR>n</VAR>-MB swap disk for a single
run with <Q><SAMP>--swap-size=<VAR>n</VAR></SAMP></Q>.
</P>
<P>

Swap slots should be allocated lazily, that is, only when they are
actually required by eviction.  Reading data pages from the executable
and writing them to swap immediately at process startup is not lazy.
Swap slots should not be reserved to store particular pages.
</P>
<P>

Free a swap slot when its contents are read back into a frame.
</P>
<P>

<A NAME="Managing Memory Mapped Files Back"></A>
<HR SIZE="6">
<A NAME="SEC66"></A>
<H3> 4.1.7 Managing Memory Mapped Files </H3>
<!--docid::SEC66::-->
<P>

The file system is most commonly accessed with <CODE>read</CODE> and
<CODE>write</CODE> system calls.  A secondary interface is to &quot;map&quot; the file
into virtual pages, using the <CODE>mmap</CODE> system call.  The program can
then use memory instructions directly on the file data.
</P>
<P>

Suppose file <Q><TT>foo</TT></Q> is <TT>0x1000</TT> bytes (4 kB, or one page) long.
If <Q><TT>foo</TT></Q> is mapped into memory starting at address <TT>0x5000</TT>, then
any memory accesses to locations <TT>0x5000</TT><small>...</small><TT>0x5fff</TT> will access
the corresponding bytes of <Q><TT>foo</TT></Q>.
</P>
<P>

Here's a program that uses <CODE>mmap</CODE> to print a file to the console.
It opens the file specified on the command line, maps it at virtual
address <TT>0x10000000</TT>, writes the mapped data to the console (fd 1),
and unmaps the file.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &lt;stdio.h&gt;
#include &lt;syscall.h&gt;
int main (int argc UNUSED, char *argv[]) 
{
  void *data = (void *) 0x10000000;     /* Address at which to map. */

  int fd = open (argv[1]);              /* Open file. */
  mapid_t map = mmap (fd, data);        /* Map file. */
  write (1, data, filesize (fd));       /* Write file to console. */
  munmap (map);                         /* Unmap file (optional). */
  return 0;
}
</pre></td></tr></table><P>

A similar program with full error handling is included as <Q><TT>mcat.c</TT></Q>
in the <Q><TT>examples</TT></Q> directory, which also contains <Q><TT>mcp.c</TT></Q> as a
second example of <CODE>mmap</CODE>.
</P>
<P>

Your submission must be able to track what memory is used by memory
mapped files.  This is necessary to properly handle page faults in the
mapped regions and to ensure that mapped files do not overlap any other
segments within the process.
</P>
<P>

<A NAME="Project 3 Suggested Order of Implementation"></A>
<HR SIZE="6">
<A NAME="SEC67"></A>
<H2> 4.2 Suggested Order of Implementation </H2>
<!--docid::SEC67::-->
<P>

We suggest the following initial order of implementation:
</P>
<P>

<OL>
<LI>
Frame table (see section <A HREF="pintos_4.html#SEC63">4.1.5 Managing the Frame Table</A>).  Change <Q><TT>process.c</TT></Q>
to use your frame table allocator.
<P>

Do not implement swapping yet.  If you run out of frames, fail the
allocator or panic the kernel.
</P>
<P>

After this step, your kernel should still pass all the project 2 test
cases.
</P>
<P>

</P>
<LI>
Supplemental page table and page fault handler (see section <A HREF="pintos_4.html#SEC62">4.1.4 Managing the Supplemental Page Table</A>).  Change <Q><TT>process.c</TT></Q> to record the
necessary information in the supplemental page table when loading an
executable and setting up its stack.  Implement loading of code and data
segments in the page fault handler.  For now, consider only valid
accesses.
<P>

After this step, your kernel should pass all of the project 2
functionality test cases, but only some of the robustness tests.
</OL>
<P>

From here, you can implement stack growth, mapped files, and page
reclamation on process exit in parallel.
</P>
<P>

The next step is to implement eviction (see section <A HREF="pintos_4.html#SEC63">4.1.5 Managing the Frame Table</A>).  Initially you could choose the page to evict randomly.  At
this point, you need to consider how to manage accessed and dirty bits
and aliasing of user and kernel pages.  Synchronization is also a
concern: how do you deal with it if process A faults on a page whose
frame process B is in the process of evicting?  Finally, implement a
eviction strategy such as the clock algorithm.
</P>
<P>

<A NAME="Project 3 Requirements"></A>
<HR SIZE="6">
<A NAME="SEC68"></A>
<H2> 4.3 Requirements </H2>
<!--docid::SEC68::-->
<P>

This assignment is an open-ended design problem.  We are going to say as
little as possible about how to do things.  Instead we will focus on
what functionality we require your OS to support.  We will expect
you to come up with a design that makes sense.  You will have the
freedom to choose how to handle page faults, how to organize the swap
partition, how to implement paging, etc.
</P>
<P>

<A NAME="Project 3 Design Document"></A>
<HR SIZE="6">
<A NAME="SEC69"></A>
<H3> 4.3.1 Design Document </H3>
<!--docid::SEC69::-->
<P>

Before you turn in your project, you must copy <A HREF="vm.tmpl">the
project 3 design document template</A> into your source tree under the name
<Q><TT>pintos/src/vm/DESIGNDOC</TT></Q> and fill it in.  We recommend that you
read the design document template before you start working on the
project.  See section <A HREF="pintos_9.html#SEC142">D. Project Documentation</A>, for a sample design document
that goes along with a fictitious project.
</P>
<P>

<A NAME="Paging"></A>
<HR SIZE="6">
<A NAME="SEC70"></A>
<H3> 4.3.2 Paging </H3>
<!--docid::SEC70::-->
<P>

Implement paging for segments loaded from executables.  All of these
pages should be loaded lazily, that is, only as the kernel intercepts
page faults for them.  Upon eviction, pages modified since load (e.g.
as indicated by the &quot;dirty bit&quot;) should be written to swap.
Unmodified pages, including read-only pages, should never be written to
swap because they can always be read back from the executable.
</P>
<P>

Implement a global page replacement algorithm that approximates LRU.
Your algorithm should perform at least as well as the simple variant
of the &quot;second chance&quot; or &quot;clock&quot; algorithm.
</P>
<P>

Your design should allow for parallelism.  If one page fault requires
I/O, in the meantime processes that do not fault should continue
executing and other page faults that do not require I/O should be able
to complete.  This will require some synchronization effort.
</P>
<P>

You'll need to modify the core of the program loader, which is the loop
in <CODE>load_segment()</CODE> in <Q><TT>userprog/process.c</TT></Q>.  Each time around
the loop, <CODE>page_read_bytes</CODE> receives the number of bytes to read
from the executable file and <CODE>page_zero_bytes</CODE> receives the number
of bytes to initialize to zero following the bytes read.  The two always
sum to <CODE>PGSIZE</CODE> (4,096).  The handling of a page depends on these
variables' values:
</P>
<P>

<UL>
<LI>
If <CODE>page_read_bytes</CODE> equals <CODE>PGSIZE</CODE>, the page should be demand
paged from the underlying file on its first access.
<P>

</P>
<LI>
If <CODE>page_zero_bytes</CODE> equals <CODE>PGSIZE</CODE>, the page does not need to
be read from disk at all because it is all zeroes.  You should handle
such pages by creating a new page consisting of all zeroes at the
first page fault.
<P>

</P>
<LI>
Otherwise, neither <CODE>page_read_bytes</CODE> nor <CODE>page_zero_bytes</CODE>
equals <CODE>PGSIZE</CODE>.  In this case, an initial part of the page is to
be read from the underlying file and the remainder zeroed.
</UL>
<P>

<A NAME="Stack Growth"></A>
<HR SIZE="6">
<A NAME="SEC71"></A>
<H3> 4.3.3 Stack Growth </H3>
<!--docid::SEC71::-->
<P>

Implement stack growth.  In project 2, the stack was a single page at
the top of the user virtual address space, and programs were limited to
that much stack.  Now, if the stack grows past its current size,
allocate additional pages as necessary.
</P>
<P>

Allocate additional pages only if they &quot;appear&quot; to be stack accesses.
Devise a heuristic that attempts to distinguish stack accesses from
other accesses.
</P>
<P>

User programs are buggy if they write to the stack below the stack
pointer, because typical real OSes may interrupt a process at any time
to deliver a &quot;signal,&quot; which pushes data on the stack.<A NAME="DOCF4" HREF="pintos_fot.html#FOOT4">(4)</A>
However, the 80<VAR>x</VAR>86 <CODE>PUSH</CODE> instruction checks access
permissions before it adjusts the stack pointer, so it may cause a page
fault 4 bytes below the stack pointer.  (Otherwise, <CODE>PUSH</CODE> would
not be restartable in a straightforward fashion.)  Similarly, the
<CODE>PUSHA</CODE> instruction pushes 32 bytes at once, so it can fault 32
bytes below the stack pointer.
</P>
<P>

You will need to be able to obtain the current value of the user
program's stack pointer.  Within a system call or a page fault generated
by a user program, you can retrieve it from the <CODE>esp</CODE> member of the
<CODE>struct intr_frame</CODE> passed to <CODE>syscall_handler()</CODE> or
<CODE>page_fault()</CODE>, respectively.  If you verify user pointers before
accessing them (see section <A HREF="pintos_3.html#SEC39">3.1.5 Accessing User Memory</A>), these are the only cases
you need to handle.  On the other hand, if you depend on page faults to
detect invalid memory access, you will need to handle another case,
where a page fault occurs in the kernel.  Since the processor only 
saves the stack pointer when an exception causes a switch from user
to kernel mode, reading <CODE>esp</CODE> out of the <CODE>struct intr_frame</CODE> 
passed to <CODE>page_fault()</CODE> would yield an undefined value, not the 
user stack pointer.  You will need to arrange another way, such as 
saving <CODE>esp</CODE> into <CODE>struct thread</CODE> on the initial transition 
from user to kernel mode.
</P>
<P>

You should impose some absolute limit on stack size, as do most OSes.
Some OSes make the limit user-adjustable, e.g. with the
<CODE>ulimit</CODE> command on many Unix systems.  On many GNU/Linux systems,
the default limit is 8 MB.
</P>
<P>

The first stack page need not be allocated lazily.  You can allocate
and initialize it with the command line arguments at load time, with 
no need to wait for it to be faulted in.
</P>
<P>

All stack pages should be candidates for eviction.  An evicted stack
page should be written to swap.
</P>
<P>

<A NAME="Memory Mapped Files"></A>
<HR SIZE="6">
<A NAME="SEC72"></A>
<H3> 4.3.4 Memory Mapped Files </H3>
<!--docid::SEC72::-->
<P>

Implement memory mapped files, including the following system calls.
</P>
<P>

<A NAME="IDX17"></A>
</P>
<DL>
<DT><U>System Call:</U> mapid_t <B>mmap</B> (int <VAR>fd</VAR>, void *<VAR>addr</VAR>)
<DD>Maps the file open as <VAR>fd</VAR> into the process's virtual address
space.  The entire file is mapped into consecutive virtual pages
starting at <VAR>addr</VAR>.
<P>

Your VM system must lazily load pages in <CODE>mmap</CODE> regions and use the
<CODE>mmap</CODE>ed file itself as backing store for the mapping.  That is,
evicting a page mapped by <CODE>mmap</CODE> writes it back to the file it was
mapped from.
</P>
<P>

If the file's length is not a multiple of <CODE>PGSIZE</CODE>, then some
bytes in the final mapped page &quot;stick out&quot; beyond the end of the
file.  Set these bytes to zero when the page is faulted in from the
file system,
and discard them when the page is written back to disk.
</P>
<P>

If successful, this function returns a &quot;mapping ID&quot; that
uniquely identifies the mapping within the process.  On failure,
it must return -1, which otherwise should not be a valid mapping id,
and the process's mappings must be unchanged.
</P>
<P>

A call to <CODE>mmap</CODE> may fail if the file open as <VAR>fd</VAR> has a
length of zero bytes.  It must fail if <VAR>addr</VAR> is not page-aligned
or if the range of pages mapped overlaps any existing set of mapped
pages, including the stack or pages mapped at executable load time.
It must also fail if <VAR>addr</VAR> is 0, because some Pintos code assumes
virtual page 0 is not mapped.  Finally, file descriptors 0 and 1,
representing console input and output, are not mappable.
</P>
</DL>
<P>

<A NAME="IDX18"></A>
</P>
<DL>
<DT><U>System Call:</U> void <B>munmap</B> (mapid_t <VAR>mapping</VAR>)
<DD>Unmaps the mapping designated by <VAR>mapping</VAR>, which must be a
mapping ID returned by a previous call to <CODE>mmap</CODE> by the same
process that has not yet been unmapped.
</DL>
<P>

All mappings are implicitly unmapped when a process exits, whether via
<CODE>exit</CODE> or by any other means.  When a mapping is unmapped, whether
implicitly or explicitly, all pages written to by the process are
written back to the file, and pages not written must not be.  The pages
are then removed from the process's list of virtual pages.
</P>
<P>

Closing or removing a file does not unmap any of its mappings.  Once
created, a mapping is valid until <CODE>munmap</CODE> is called or the process
exits, following the Unix convention.  See  <A HREF="pintos_3.html#Removing an Open File">Removing an Open File</A>, for
more information.  You should use the <CODE>file_reopen</CODE> function to
obtain a separate and independent reference to the file for each of
its mappings.
</P>
<P>

If two or more processes map the same file, there is no requirement that
they see consistent data.  Unix handles this by making the two mappings
share the same physical page, but the <CODE>mmap</CODE> system call also has
an argument allowing the client to specify whether the page is shared or
private (i.e. copy-on-write).
</P>
<P>

<HR SIZE="6">
<A NAME="SEC73"></A>
<H3> 4.3.5 Accessing User Memory </H3>
<!--docid::SEC73::-->
You will need to adapt your code to access user memory (see section <A HREF="pintos_3.html#SEC39">3.1.5 Accessing User Memory</A>) while handling a system call.  Just as user processes may
access pages whose content is currently in a file or in swap space, so
can they pass addresses that refer to such non-resident pages to system
calls.  Moreover, unless your kernel takes measures to prevent this,
a page may be evicted from its frame even while it is being accessed
by kernel code.  If kernel code accesses such non-resident user pages,
a page fault will result.
<P>

While accessing user memory, your kernel must either be prepared to handle
such page faults, or it must prevent them from occurring.  The kernel 
must prevent such page faults while it is holding resources it would 
need to acquire to handle these faults.  In Pintos, such resources include
locks acquired by the device driver(s) that control the device(s) containing 
the file system and swap space.  As a concrete example, you must not 
allow page faults to occur while a device driver accesses a user buffer
passed to <CODE>file_read</CODE>, because you would not be able to invoke
the driver while handling such faults.
</P>
<P>

Preventing such page faults requires cooperation between the code within
which the access occurs and your page eviction code.  For instance,
you could extend your frame table to record when a page contained in
a frame must not be evicted.  (This is also referred to as &quot;pinning&quot;
or &quot;locking&quot; the page in its frame.)  Pinning restricts your page
replacement algorithm's choices when looking for pages to evict, so be
sure to pin pages no longer than necessary, and avoid pinning pages when
it is not necessary.
</P>
<P>

<A NAME="Project 3 FAQ"></A>
<HR SIZE="6">
<A NAME="SEC74"></A>
<H2> 4.4 FAQ </H2>
<!--docid::SEC74::-->
<P>

</P>
<DL COMPACT>
<DT><B>How much code will I need to write?</B>
<DD><P>

Here's a summary of our reference solution, produced by the
<CODE>diffstat</CODE> program.  The final row gives total lines inserted
and deleted; a changed line counts as both an insertion and a deletion.
</P>
<P>

This summary is relative to the Pintos base code, but the reference
solution for project 3 starts from the reference solution to project 2.
See section <A HREF="pintos_3.html#SEC47">3.4 FAQ</A>, for the summary of project 2.
</P>
<P>

The reference solution represents just one possible solution.  Many
other solutions are also possible and many of those differ greatly from
the reference solution.  Some excellent solutions may not modify all the
files modified by the reference solution, and some may modify files not
modified by the reference solution.
</P>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> Makefile.build       |    4
 devices/timer.c      |   42 ++
 threads/init.c       |    5
 threads/interrupt.c  |    2
 threads/thread.c     |   31 +
 threads/thread.h     |   37 +-
 userprog/exception.c |   12
 userprog/pagedir.c   |   10
 userprog/process.c   |  319 +++++++++++++-----
 userprog/syscall.c   |  545 ++++++++++++++++++++++++++++++-
 userprog/syscall.h   |    1
 vm/frame.c           |  162 +++++++++
 vm/frame.h           |   23 +
 vm/page.c            |  297 ++++++++++++++++
 vm/page.h            |   50 ++
 vm/swap.c            |   85 ++++
 vm/swap.h            |   11
 17 files changed, 1532 insertions(+), 104 deletions(-)
</pre></td></tr></table><P>

</P>
<DT><B>Do we need a working Project 2 to implement Project 3?</B>
<DD><P>

Yes.
</P>
<P>

</P>
<DT><B>What extra credit is available?</B>
<DD><A NAME="VM Extra Credit"></A>
<P>

You may implement sharing: when multiple processes are created that use
the same executable file, share read-only pages among those processes
instead of creating separate copies of read-only segments for each
process.  If you carefully designed your data structures,
sharing of read-only pages should not make this part significantly
harder.
</P>
<P>

</P>
<DT><B>How do we resume a process after we have handled a page fault?</B>
<DD><P>

Returning from <CODE>page_fault()</CODE> resumes the current user process
(see section <A HREF="pintos_6.html#SEC109">A.4.2 Internal Interrupt Handling</A>).
It will then retry the instruction to which the instruction pointer points.
</P>
<P>

</P>
<DT><B>Why do user processes sometimes fault above the stack pointer?</B>
<DD><P>

You might notice that, in the stack growth tests, the user program faults
on an address that is above the user program's current stack pointer,
even though the <CODE>PUSH</CODE> and <CODE>PUSHA</CODE> instructions would cause
faults 4 and 32 bytes below the current stack pointer.
</P>
<P>

This is not unusual.  The <CODE>PUSH</CODE> and <CODE>PUSHA</CODE> instructions are
not the only instructions that can trigger user stack growth.
For instance, a user program may allocate stack space by decrementing the 
stack pointer using a <CODE>SUB $n, %esp</CODE> instruction, and then use a 
<CODE>MOV ..., m(%esp)</CODE> instruction to write to a stack location within
the allocated space that is <VAR>m</VAR> bytes above the current stack pointer.  
Such accesses are perfectly valid, and your kernel must grow the 
user program's stack to allow those accesses to succeed.
</P>
<P>

</P>
<DT><B>Does the virtual memory system need to support data segment growth?</B>
<DD><P>

No.  The size of the data segment is determined by the linker.  We still
have no dynamic allocation in Pintos (although it is possible to
&quot;fake&quot; it at the user level by using memory-mapped files).  Supporting
data segment growth should add little additional complexity to a
well-designed system.
</P>
<P>

</P>
<DT><B>Why should I use <CODE>PAL_USER</CODE> for allocating page frames?</B>
<DD><A NAME="Why PAL_USER?"></A>
<P>

Passing <CODE>PAL_USER</CODE> to <CODE>palloc_get_page()</CODE> causes it to allocate
memory from the user pool, instead of the main kernel pool.  Running out
of pages in the user pool just causes user programs to page, but running
out of pages in the kernel pool will cause many failures because so many
kernel functions need to obtain memory.
You can layer some other allocator on top of <CODE>palloc_get_page()</CODE> if
you like, but it should be the underlying mechanism.
</P>
<P>

Also, you can use the <Q><SAMP>-ul</SAMP></Q> kernel command-line option to limit
the size of the user pool, which makes it easy to test your VM
implementation with various user memory sizes.
</DL>
<A NAME="Project 4--File Systems"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_4.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_5.html#SEC75"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>
<FONT SIZE="-1">
This document was generated
by on <I>October, 26 2020</I>
using <A HREF="http://texi2html.cvshome.org"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
